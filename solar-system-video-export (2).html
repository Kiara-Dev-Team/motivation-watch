<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Solar System - Video Export</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;
    }
    canvas { display: block; }
    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 14px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="info">
    Solar System - Top View<br>
    Scroll to zoom
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Setup scene, camera, and renderer
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.position.set(0, 150, 0); // Top-down view
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ 
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create sun
    const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffff00,
      emissive: 0xffaa00
    });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // Sun glow effect
    const sunGlowGeometry = new THREE.SphereGeometry(7, 32, 32);
    const sunGlowMaterial = new THREE.MeshBasicMaterial({
      color: 0xffaa00,
      transparent: true,
      opacity: 0.3
    });
    const sunGlow = new THREE.Mesh(sunGlowGeometry, sunGlowMaterial);
    scene.add(sunGlow);

    // Point light from sun
    const sunLight = new THREE.PointLight(0xffffff, 2, 500);
    scene.add(sunLight);

    // Planet data: [size, distance from sun, orbital speed, color, name]
    const planetData = [
      [0.8, 12, 0.006, 0x8c7853, 'Mercury'],
      [1.2, 18, 0.0045, 0xffd700, 'Venus'],
      [1.3, 25, 0.003, 0x4169e1, 'Earth'],
      [1.0, 32, 0.0024, 0xff4500, 'Mars'],
      [3.5, 48, 0.0012, 0xdaa520, 'Jupiter'],
      [3.0, 65, 0.0009, 0xf4a460, 'Saturn'],
      [2.0, 80, 0.0006, 0x4fd5d5, 'Uranus'],
      [2.0, 95, 0.0003, 0x4169e1, 'Neptune']
    ];

    // Create planets
    const planets = [];
    
    planetData.forEach((data, index) => {
      const [size, distance, speed, color, name] = data;
      
      const geometry = new THREE.SphereGeometry(size, 64, 64);
      let material;
      
      if (name === 'Mercury') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0x8c7853, roughness: 0.9, metalness: 0.1,
          emissive: 0x221100, emissiveIntensity: 0.1
        });
      } else if (name === 'Venus') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0xffc870, roughness: 0.6, metalness: 0.2,
          emissive: 0x664400, emissiveIntensity: 0.2
        });
      } else if (name === 'Earth') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0x2233ff, roughness: 0.7, metalness: 0.4,
          emissive: 0x001133, emissiveIntensity: 0.3
        });
      } else if (name === 'Mars') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0xcc4422, roughness: 0.9, metalness: 0.1,
          emissive: 0x220000, emissiveIntensity: 0.2
        });
      } else if (name === 'Jupiter') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0xddaa77, roughness: 0.5, metalness: 0.3,
          emissive: 0x443322, emissiveIntensity: 0.2
        });
      } else if (name === 'Saturn') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0xf4d03f, roughness: 0.6, metalness: 0.3,
          emissive: 0x554422, emissiveIntensity: 0.2
        });
      } else if (name === 'Uranus') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0x4fd5d5, roughness: 0.4, metalness: 0.5,
          emissive: 0x003344, emissiveIntensity: 0.3
        });
      } else if (name === 'Neptune') {
        material = new THREE.MeshStandardMaterial({ 
          color: 0x4169e1, roughness: 0.4, metalness: 0.5,
          emissive: 0x001155, emissiveIntensity: 0.3
        });
      }
      
      const planet = new THREE.Mesh(geometry, material);
      
      // Add atmospheric glow for gas giants and Earth
      if (['Earth', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'].includes(name)) {
        const glowGeometry = new THREE.SphereGeometry(size * 1.15, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: color, transparent: true, opacity: 0.15, side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        planet.add(glow);
      }
      
      // Elliptical orbit path - each planet has different eccentricity
      // Real eccentricity values for accurate orbit shapes
      const eccentricities = [0.206, 0.007, 0.017, 0.093, 0.048, 0.056, 0.047, 0.009];
      const eccentricity = eccentricities[index] || 0.01;
      
      const orbitGeometry = new THREE.BufferGeometry();
      const orbitPoints = [];
      const segments = 128; // High segment count for smooth ellipses
      
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        
        // Calculate elliptical radius using orbital mechanics formula
        const r = distance * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(angle));
        
        orbitPoints.push(
          Math.cos(angle) * r,
          0,
          Math.sin(angle) * r
        );
      }
      orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
      
      // Gray orbit lines
      const orbitMaterial = new THREE.LineBasicMaterial({ 
        color: 0x888888,
        transparent: true,
        opacity: 0.7,
        linewidth: 2
      });
      const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
      scene.add(orbit);
      
      // Store planet data
      planets.push({
        mesh: planet, distance: distance, speed: speed,
        angle: Math.random() * Math.PI * 2, name: name
      });
      
      scene.add(planet);
    });

    // Saturn's rings
    const saturnRingGeometry = new THREE.RingGeometry(4.5, 7, 64);
    const saturnRingMaterial = new THREE.MeshBasicMaterial({
      color: 0xe8d5b7, side: THREE.DoubleSide, transparent: true, opacity: 0.7
    });
    const saturnRing = new THREE.Mesh(saturnRingGeometry, saturnRingMaterial);
    saturnRing.rotation.x = Math.PI / 2 + 0.3;
    
    const innerRingGeometry = new THREE.RingGeometry(4, 4.3, 64);
    const innerRingMaterial = new THREE.MeshBasicMaterial({
      color: 0xccaa88, side: THREE.DoubleSide, transparent: true, opacity: 0.8
    });
    const innerRing = new THREE.Mesh(innerRingGeometry, innerRingMaterial);
    innerRing.rotation.x = Math.PI / 2 + 0.3;
    
    planets[5].ring = saturnRing;
    planets[5].innerRing = innerRing;

    // Earth's moon
    const moonGeometry = new THREE.SphereGeometry(0.4, 32, 32);
    const moonMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xcccccc, roughness: 0.95, metalness: 0.05,
      emissive: 0x111111, emissiveIntensity: 0.1
    });
    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
    planets[2].moon = moon;
    planets[2].moonAngle = 0;

    // Add moons to planets - accurate counts
    // Mercury: 0, Venus: 0, Earth: 1, Mars: 2
    // Jupiter: 10 (showing major moons), Saturn: 15 (showing major moons)
    // Uranus: 28, Neptune: 16
    
    const moonData = [
      { planetIndex: 0, count: 0 }, // Mercury - no moons
      { planetIndex: 1, count: 0 }, // Venus - no moons
      { planetIndex: 2, count: 1 }, // Earth - 1 moon
      { planetIndex: 3, count: 2 }, // Mars - 2 moons
      { planetIndex: 4, count: 10 }, // Jupiter - 10 major moons
      { planetIndex: 5, count: 15 }, // Saturn - 15 major moons
      { planetIndex: 6, count: 28 }, // Uranus - 28 moons
      { planetIndex: 7, count: 16 }  // Neptune - 16 moons
    ];
    
    moonData.forEach(data => {
      const planet = planets[data.planetIndex];
      const size = planet.mesh.geometry.parameters.radius;
      
      if (data.planetIndex === 2) {
        // Earth already has moon defined above
        planet.moonDistance = 3;
        planet.moons = [{ mesh: planet.moon, angle: 0, distance: 3, speed: 0.015 }];
      } else if (data.count > 0) {
        // Create all moons
        planet.moons = [];
        for (let i = 0; i < data.count; i++) {
          // Vary moon sizes - smaller for gas giants with many moons
          const moonSize = data.count > 10 
            ? size * (0.05 + Math.random() * 0.05) 
            : size * (0.1 + Math.random() * 0.1);
            
          const moonGeom = new THREE.SphereGeometry(moonSize, 8, 8);
          const moonMat = new THREE.MeshStandardMaterial({ 
            color: 0xaaaaaa, 
            roughness: 0.95, 
            metalness: 0.05,
            emissive: 0x111111, 
            emissiveIntensity: 0.1
          });
          const moonMesh = new THREE.Mesh(moonGeom, moonMat);
          
          // Distribute moons in orbital layers
          const layer = Math.floor(i / Math.ceil(data.count / 5)); // 5 layers max
          const moonsInLayer = Math.ceil(data.count / 5);
          const angleOffset = (i % moonsInLayer) * (Math.PI * 2 / moonsInLayer);
          
          planet.moons.push({
            mesh: moonMesh,
            angle: angleOffset,
            distance: size * (2 + layer * 0.6), // Layers at different distances
            speed: 0.02 / (1 + layer * 0.3) // Outer layers slower
          });
        }
      }
    });

    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);

    // Add famous comets with elliptical orbits
    const comets = [];
    
    // Comet data: [name, semi-major axis, eccentricity, orbital period (years), color]
    const cometData = [
      ["Halley's Comet", 130, 0.967, 75.3, 0x88ccff],      // Returns every 75-76 years
      ["Comet Encke", 45, 0.847, 3.3, 0xaaddff],           // Short period 3.3 years
      ["Comet Tempel 1", 55, 0.517, 5.56, 0x99ddff],       // Deep Impact mission - 5.56 years
      ["Comet Wild 2", 60, 0.540, 6.41, 0xbbddff],         // Stardust spacecraft - 6.41 years
      ["Comet Borrelly", 58, 0.624, 6.9, 0xccddff]         // Deep Space 1 - 6.9 years
    ];
    
    cometData.forEach(data => {
      const [name, semiMajor, eccentricity, period, color] = data;
      
      // Comet nucleus (small)
      const cometGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const cometMaterial = new THREE.MeshBasicMaterial({ 
        color: color,
        emissive: color,
        emissiveIntensity: 0.5
      });
      const comet = new THREE.Mesh(cometGeometry, cometMaterial);
      
      // Comet tail (cone shape)
      const tailGeometry = new THREE.ConeGeometry(0.5, 8, 8);
      const tailMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.4
      });
      const tail = new THREE.Mesh(tailGeometry, tailMaterial);
      tail.rotation.x = Math.PI / 2; // Point backwards
      tail.position.z = -4; // Behind the comet
      comet.add(tail);
      
      // Comet glow
      const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.3
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      comet.add(glow);
      
      // Draw elliptical orbit
      const orbitGeometry = new THREE.BufferGeometry();
      const orbitPoints = [];
      const segments = 128;
      
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const r = semiMajor * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(angle));
        
        orbitPoints.push(
          Math.cos(angle) * r,
          0,
          Math.sin(angle) * r
        );
      }
      orbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(orbitPoints, 3));
      
      const orbitMaterial = new THREE.LineBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.4,
        linewidth: 1
      });
      const orbit = new THREE.Line(orbitGeometry, orbitMaterial);
      scene.add(orbit);
      
      comets.push({
        mesh: comet,
        semiMajor: semiMajor,
        eccentricity: eccentricity,
        angle: Math.random() * Math.PI * 2,
        speed: 0.01 / period, // Slower for longer periods
        name: name,
        tail: tail
      });
      
      scene.add(comet);
    });

    // Mouse wheel zoom control
    let cameraDistance = 150;
    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraDistance += e.deltaY * 0.1;
      cameraDistance = Math.max(50, Math.min(400, cameraDistance)); // Clamp between 50-400
      camera.position.y = cameraDistance;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      sun.rotation.y += 0.0003;
      sunGlow.rotation.y += 0.0003;
      
      planets.forEach((planet) => {
        planet.angle += planet.speed;
        planet.mesh.position.x = Math.cos(planet.angle) * planet.distance;
        planet.mesh.position.z = Math.sin(planet.angle) * planet.distance;
        planet.mesh.rotation.y += 0.003;
        
        if (planet.ring) {
          planet.ring.position.copy(planet.mesh.position);
          planet.ring.rotation.z += 0.0003;
          
          if (planet.innerRing) {
            planet.innerRing.position.copy(planet.mesh.position);
            planet.innerRing.rotation.z += 0.00018;
          }
        }
        
        // Update moons
        if (planet.moons) {
          planet.moons.forEach(moonData => {
            moonData.angle += moonData.speed;
            moonData.mesh.position.x = planet.mesh.position.x + Math.cos(moonData.angle) * moonData.distance;
            moonData.mesh.position.z = planet.mesh.position.z + Math.sin(moonData.angle) * moonData.distance;
            
            if (!scene.children.includes(moonData.mesh)) {
              scene.add(moonData.mesh);
            }
          });
        }
      });
      
      if (planets[5].ring && !scene.children.includes(planets[5].ring)) {
        scene.add(planets[5].ring);
      }
      if (planets[5].innerRing && !scene.children.includes(planets[5].innerRing)) {
        scene.add(planets[5].innerRing);
      }
      
      // Update comets with elliptical orbits
      comets.forEach(comet => {
        // Calculate position using orbital mechanics
        comet.angle += comet.speed;
        const r = comet.semiMajor * (1 - comet.eccentricity * comet.eccentricity) / 
                  (1 + comet.eccentricity * Math.cos(comet.angle));
        
        comet.mesh.position.x = Math.cos(comet.angle) * r;
        comet.mesh.position.z = Math.sin(comet.angle) * r;
        
        // Point tail away from sun
        const sunDirection = new THREE.Vector3(0, 0, 0).sub(comet.mesh.position).normalize();
        comet.mesh.lookAt(sunDirection.add(comet.mesh.position));
        
        // Rotate comet nucleus
        comet.mesh.rotation.y += 0.02;
      });
      
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>